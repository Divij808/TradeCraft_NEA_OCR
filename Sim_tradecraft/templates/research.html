{% extends "layout.html" %}
{% block title %}Research - TradeCraft{% endblock %}

{% set active_page = 'research' %}

{% block content %}
<div class="card">
  <h1>Research</h1>
</div>

<div class="search-bar" style="max-width: 1000px; margin: 0 auto 1.5rem; padding: 0 1rem;">
  <input type="text" id="searchInput" placeholder="Search stocks by symbol, name, or sector..." style="width: 100%;">
</div>

<div id="research-cards">
  {% for c in companies %}
    <div class="research-card">
      <h2>{{ c.symbol }} - {{ c.name }}</h2>
      <h3>{{ c.sector }}</h3>
      <p>Live quote: <span id="q_{{ c.symbol }}">{{ '%.2f'|format(c.live_price) if c.live_price else 'N/A' }}</span></p>

      <form method="post" action="{{ url_for('trade') }}" style="margin-top: 1rem;">
        <input type="hidden" name="symbol" value="{{ c.symbol }}">
        <input type="hidden" name="qty" value="1">
        <input type="hidden" name="side" value="BUY">
        <button class="primary" style="width: 100%;">Buy 1 share</button>
      </form>
    </div>
  {% endfor %}
</div>
{% endblock %}

{% block scripts %}
<script>
function getTheme() {
  try {
    return localStorage.getItem('theme') || 'light';
  } catch (e) {
    return 'light';
  }
}

const currentTheme = getTheme();
if (currentTheme === 'dark') {
  document.documentElement.setAttribute('data-theme', 'dark');
}

const previousPrices = {};
let updateInterval = null;
let rateLimitErrorCount = 0;
let isUpdating = false;

async function updateQuotes() {
  if (isUpdating) {
    return;
  }

  if (rateLimitErrorCount >= 3) {
    if (updateInterval) {
      clearInterval(updateInterval);
      updateInterval = null;
    }
    return;
  }

  const symbolElements = document.querySelectorAll('[id^="q_"]');
  if (symbolElements.length === 0) return;

  isUpdating = true;

  const symbols = Array.from(symbolElements).map(el => el.id.replace('q_', '')).join(',');

  try {
    const res = await fetch(`/api/quote?symbols=${symbols}`);

    if (!res.ok) {
      if (res.status === 429) {
        rateLimitErrorCount++;
        if (updateInterval) {
          clearInterval(updateInterval);
          updateInterval = setInterval(updateQuotes, 30000);
        }
      }
      throw new Error(`HTTP error! status: ${res.status}`);
    }

    const data = await res.json();
    rateLimitErrorCount = 0;

    symbolElements.forEach(el => {
      const symbol = el.id.replace('q_', '');
      if (data.quotes[symbol] && data.quotes[symbol].price != null) {
        const price = parseFloat(data.quotes[symbol].price).toFixed(2);
        const prev = previousPrices[symbol] || parseFloat(el.innerText.replace('$','')) || 0;
        if (price > prev) {
          el.style.color = 'green';
        } else if (price < prev) {
          el.style.color = 'red';
        } else {
          const theme = getTheme();
          el.style.color = theme === 'dark' ? '#e2e8f0' : '#0f172a';
        }
        el.innerText = `$${price}`;
        previousPrices[symbol] = parseFloat(price);
      }
    });
  } catch (err) {
    console.error("Failed to update quotes:", err);
  } finally {
    isUpdating = false;
  }
}

updateInterval = setInterval(updateQuotes, 30000);

document.getElementById('searchInput').addEventListener('input', function(e) {
  const searchTerm = e.target.value.toLowerCase().trim();
  const cards = document.querySelectorAll('#cards > .card');

  cards.forEach(card => {
    const symbol = card.querySelector('h2')?.textContent.toLowerCase() || '';
    const sector = card.querySelector('h3')?.textContent.toLowerCase() || '';

    if (symbol.includes(searchTerm) || sector.includes(searchTerm)) {
      card.style.display = '';
    } else {
      card.style.display = 'none';
    }
  });
});
</script>
{% endblock %}
